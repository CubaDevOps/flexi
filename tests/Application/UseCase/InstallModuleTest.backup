<?php

declare(strict_types=1);

namespace CubaDevOps\Flexi\Test\Application\UseCase;

use CubaDevOps\Flexi\Application\Commands\InstallModuleCommand;
use CubaDevOps\Flexi\Application\UseCase\InstallModule;
use Flexi\Contracts\Interfaces\HandlerInterface;
use Flexi\Contracts\Interfaces\MessageInterface;
use PHPUnit\Framework\TestCase;
use RuntimeException;

class InstallModuleTest extends TestCase
{
    private string $tempDir;
    private string $modulesPath;
    private string $composerPath;
    private string $rootPath;
    private InstallModule $installModule;

    protected function setUp(): void
    {
        $this->tempDir = sys_get_temp_dir() . '/flexi_install_test_' . uniqid();
        $this->rootPath = $this->tempDir;
        $this->modulesPath = $this->tempDir . '/modules';
        $this->composerPath = $this->tempDir . '/composer.json';

        mkdir($this->tempDir, 0777, true);
        mkdir($this->modulesPath, 0777, true);

        $this->installModule = new InstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );
    }

    protected function tearDown(): void
    {
        $this->cleanupTempDir($this->tempDir);
    }

    private function cleanupTempDir(string $dir): void
    {
        if (!is_dir($dir)) {
            return;
        }

        $files = array_diff(scandir($dir), ['.', '..']);
        foreach ($files as $file) {
            $path = $dir . '/' . $file;
            if (is_dir($path)) {
                $this->cleanupTempDir($path);
            } else {
                unlink($path);
            }
        }
        rmdir($dir);
    }

    private function createComposerJson(array $data): void
    {
        file_put_contents($this->composerPath, json_encode($data, JSON_PRETTY_PRINT));
    }

    private function createModuleWithComposer(string $moduleName, array $composerData): void
    {
        $modulePath = $this->modulesPath . '/' . $moduleName;
        mkdir($modulePath, 0777, true);

        $composerPath = $modulePath . '/composer.json';
        file_put_contents($composerPath, json_encode($composerData, JSON_PRETTY_PRINT));
    }

    public function testImplementsHandlerInterface(): void
    {
        $this->assertInstanceOf(HandlerInterface::class, $this->installModule);
    }

    public function testConstructorWithDefaultPaths(): void
    {
        $useCase = new InstallModule();
        $this->assertInstanceOf(InstallModule::class, $useCase);
        $this->assertInstanceOf(HandlerInterface::class, $useCase);
    }

    public function testConstructorWithCustomPaths(): void
    {
        $customModules = '/custom/modules';
        $customComposer = '/custom/composer.json';
        $customRoot = '/custom/root';

        $useCase = new InstallModule($customModules, $customComposer, $customRoot);
        $this->assertInstanceOf(InstallModule::class, $useCase);
    }

    public function testHandleThrowsExceptionWhenModuleNotFound(): void
    {
        $dto = new InstallModuleCommand(['module_name' => 'NonExistentModule']);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage("Module 'NonExistentModule' not found in {$this->modulesPath}");

        $this->installModule->handle($dto);
    }

    public function testHandleThrowsExceptionWhenModuleHasNoComposerJson(): void
    {
        $moduleName = 'BrokenModule';
        $modulePath = $this->modulesPath . '/' . $moduleName;
        mkdir($modulePath);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage("Module 'BrokenModule' has no composer.json");

        $this->installModule->handle($dto);
    }

    public function testHandleThrowsExceptionWhenModuleComposerHasNoName(): void
    {
        $moduleName = 'InvalidModule';
        $this->createModuleWithComposer($moduleName, ['description' => 'Module without name']);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage("Module 'InvalidModule' composer.json has no 'name' field");

        $this->installModule->handle($dto);
    }

    public function testHandleWithModuleAlreadyInstalled(): void
    {
        $moduleName = 'ExistingModule';
        $packageName = 'cubadevops/flexi-module-existing';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '1.0.0',
            'description' => 'Test module'
        ]);

        $this->createComposerJson([
            'require' => [
                $packageName => '@dev'
            ]
        ]);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);
        $result = $this->installModule->handle($dto);

        $this->assertInstanceOf(MessageInterface::class, $result);
        $response = json_decode($result->__toString(), true);

        $this->assertTrue($response['success']);
        $this->assertEquals("Module 'ExistingModule' is already installed", $response['message']);
        $this->assertEquals($packageName, $response['package']);
        $this->assertEquals('none', $response['action']);
    }

    public function testHandleCapitalizesModuleName(): void
    {
        $this->createComposerJson(['require' => []]);

        // Create module with capitalized name
        $this->createModuleWithComposer('TestModule', [
            'name' => 'test/test-module'
        ]);

        $dto = new InstallModuleCommand(['module_name' => 'testModule']);

        // This should find the TestModule directory (capitalized)
        try {
            $result = $this->installModule->handle($dto);
            $response = json_decode($result->__toString(), true);
            $this->assertStringContainsString('TestModule', $response['message']);
        } catch (RuntimeException $e) {
            // Expected when composer command fails - at least we tested the name handling
            $this->assertStringContainsString('Failed to install module', $e->getMessage());
        }
    }

    public function testHandleAddsRepositoryWhenNotExists(): void
    {
        $moduleName = 'NewModule';
        $packageName = 'test/new-module';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '1.0.0'
        ]);

        $this->createComposerJson([
            'require' => [],
            'repositories' => []
        ]);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        try {
            $this->installModule->handle($dto);
        } catch (RuntimeException $e) {
            // Expected when composer execution fails
        }

        // Check that repository was added to composer.json
        $composerData = json_decode(file_get_contents($this->composerPath), true);
        $this->assertArrayHasKey('repositories', $composerData);

        $repositoryAdded = false;
        foreach ($composerData['repositories'] as $repo) {
            if (isset($repo['url']) && $repo['url'] === "./modules/{$moduleName}") {
                $repositoryAdded = true;
                $this->assertEquals('path', $repo['type']);
                $this->assertTrue($repo['options']['symlink']);
                break;
            }
        }
        $this->assertTrue($repositoryAdded, 'Repository was not added to composer.json');
    }

    public function testHandleDoesNotDuplicateExistingRepository(): void
    {
        $moduleName = 'ExistingRepo';
        $packageName = 'test/existing-repo';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '1.0.0'
        ]);

        $this->createComposerJson([
            'require' => [],
            'repositories' => [
                [
                    'type' => 'path',
                    'url' => './modules/ExistingRepo',
                    'options' => ['symlink' => true]
                ]
            ]
        ]);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        try {
            $this->installModule->handle($dto);
        } catch (RuntimeException $e) {
            // Expected when composer execution fails
        }

        // Check that repository was not duplicated
        $composerData = json_decode(file_get_contents($this->composerPath), true);
        $this->assertCount(1, $composerData['repositories']);
    }

    public function testHandleAddsPackageToRequire(): void
    {
        $moduleName = 'TestModule';
        $packageName = 'test/test-module';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '2.1.0'
        ]);

        $this->createComposerJson([
            'require' => [
                'some/other-package' => '^1.0'
            ]
        ]);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        try {
            $this->installModule->handle($dto);
        } catch (RuntimeException $e) {
            // Expected when composer execution fails
        }

        // Check that package was added to require with @dev version
        $composerData = json_decode(file_get_contents($this->composerPath), true);
        $this->assertArrayHasKey($packageName, $composerData['require']);
        $this->assertEquals('@dev', $composerData['require'][$packageName]);
        $this->assertCount(2, $composerData['require']); // Original package + new package
    }

    public function testHandleThrowsExceptionWhenComposerJsonCannotBeWritten(): void
    {
        $moduleName = 'TestModule';
        $packageName = 'test/test-module';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '1.0.0'
        ]);

        // Create a read-only composer.json
        $this->createComposerJson(['require' => []]);
        chmod($this->composerPath, 0444);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        // The error could be from writing composer.json OR from composer execution
        $this->expectException(RuntimeException::class);
        // Don't check specific message since it could be composer execution error

        try {
            $this->installModule->handle($dto);
        } finally {
            // Restore permissions for cleanup
            chmod($this->composerPath, 0644);
        }
    }

    public function testHandleThrowsExceptionWhenModuleComposerJsonIsInvalid(): void
    {
        $moduleName = 'InvalidJsonModule';
        $modulePath = $this->modulesPath . '/' . $moduleName;
        mkdir($modulePath, 0777, true);

        // Create invalid JSON
        file_put_contents($modulePath . '/composer.json', '{ invalid json }');

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        $this->expectException(\JsonException::class);

        $this->installModule->handle($dto);
    }

    public function testWriteComposerJsonPreservesFormatting(): void
    {
        $testData = [
            'name' => 'test/project',
            'require' => [
                'php' => '>=7.4',
                'test/package' => '@dev'
            ],
            'repositories' => [
                [
                    'type' => 'path',
                    'url' => './modules/TestModule',
                    'options' => ['symlink' => true]
                ]
            ]
        ];

        file_put_contents($this->composerPath, json_encode($testData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n");

        $content = file_get_contents($this->composerPath);

        // Verify proper formatting
        $this->assertStringContainsString('    "name": "test/project"', $content);
        $this->assertStringContainsString('./modules/TestModule', $content); // No escaped slashes
        $this->assertStringEndsWith("\n", $content); // Ends with newline
    }

    public function testHandleSuccessfulInstallation(): void
    {
        $moduleName = 'SuccessModule';
        $packageName = 'test/success-module';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '1.5.0'
        ]);

        $this->createComposerJson([
            'require' => [
                'php' => '>=7.4'
            ]
        ]);

        $testableInstall = new TestableInstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );

        // Mock successful composer output
        $testableInstall->setComposerShouldFail(false, [
            'Loading composer repositories with package information',
            'Updating dependencies',
            'Package test/success-module installed successfully'
        ]);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);
        $result = $testableInstall->handle($dto);

        $this->assertInstanceOf(MessageInterface::class, $result);
        $response = json_decode($result->__toString(), true);

        $this->assertTrue($response['success']);
        $this->assertEquals("Module 'SuccessModule' installed successfully", $response['message']);
        $this->assertEquals($packageName, $response['package']);
        $this->assertEquals('1.5.0', $response['version']);
        $this->assertEquals('installed', $response['action']);
        $this->assertArrayHasKey('output', $response);
        $this->assertCount(3, $response['output']);

        // Verify composer.json was updated
        $composerData = json_decode(file_get_contents($this->composerPath), true);
        $this->assertArrayHasKey($packageName, $composerData['require']);
        $this->assertEquals('@dev', $composerData['require'][$packageName]);
    }

    public function testHandleComposerUpdateFailure(): void
    {
        $moduleName = 'FailModule';
        $packageName = 'test/fail-module';

        $this->createModuleWithComposer($moduleName, [
            'name' => $packageName,
            'version' => '1.0.0'
        ]);

        $this->createComposerJson(['require' => []]);

        $testableInstall = new TestableInstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );

        // Mock composer failure
        $testableInstall->setComposerShouldFail(true, [
            'Loading composer repositories with package information',
            'Problem 1',
            '- Root composer.json requires test/fail-module, it could not be found'
        ]);

        $dto = new InstallModuleCommand(['module_name' => $moduleName]);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage("Failed to install module 'FailModule':");
        $this->expectExceptionMessage('Root composer.json requires test/fail-module, it could not be found');

        $testableInstall->handle($dto);
    }

    public function testWriteComposerJsonFailure(): void
    {
        // Test the exception handling in writeJsonToFile method
        $testableInstall = new TestableInstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );

        // Mock file write failure
        $testableInstall->setWriteShouldFail(true);

        $testData = ['name' => 'test/project', 'require' => []];

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Failed to write composer.json');

        $testableInstall->exposeWriteComposerJson($testData);
    }

    public function testFormatComposerJson(): void
    {
        $testableInstall = new TestableInstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );

        $testData = [
            'name' => 'test/project',
            'require' => [
                'php' => '>=7.4',
                'test/package' => '@dev'
            ],
            'repositories' => [
                [
                    'type' => 'path',
                    'url' => './modules/TestModule'
                ]
            ]
        ];

        $result = $testableInstall->exposeFormatComposerJson($testData);

        // Verify JSON formatting
        $this->assertStringContainsString('"name": "test/project"', $result);
        $this->assertStringContainsString('./modules/TestModule', $result); // No escaped slashes
        $this->assertStringContainsString('    ', $result); // Pretty print indentation

        // Verify it's valid JSON
        $decoded = json_decode($result, true);
        $this->assertEquals($testData, $decoded);
    }

    public function testWriteComposerJsonSuccess(): void
    {
        $testableInstall = new TestableInstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );

        $testData = [
            'name' => 'test/project',
            'require' => [
                'test/package' => '@dev'
            ]
        ];

        // This should work without throwing any exception
        $testableInstall->exposeWriteComposerJson($testData);

        // Verify the file was written correctly
        $this->assertFileExists($this->composerPath);
        $content = file_get_contents($this->composerPath);
        $this->assertStringContainsString('"name": "test/project"', $content);
        $this->assertStringEndsWith("\n", $content);

        $decoded = json_decode($content, true);
        $this->assertEquals($testData, $decoded);
    }

    public function testWriteJsonToFileRealFailure(): void
    {
        // Test real exception handling in writeJsonToFile with invalid path
        $invalidPath = '/proc/1/cannot-write-here.json';

        $installModule = new InstallModule(
            $this->modulesPath,
            $invalidPath,
            $this->rootPath
        );

        $testData = ['name' => 'test/project'];

        // Create a reflection to access the protected method
        $reflection = new \ReflectionClass($installModule);
        $method = $reflection->getMethod('writeJsonToFile');
        $method->setAccessible(true);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Failed to write composer.json:');

        $method->invoke($installModule, $invalidPath, json_encode($testData));
    }

    public function testRunComposerUpdateRealFailure(): void
    {
        // Test the real composer failure path
        $moduleName = 'TestModule';
        $packageName = 'test/test-module';

        $installModule = new InstallModule(
            $this->modulesPath,
            $this->composerPath,
            '/nonexistent/root/path' // This will cause composer to fail
        );

        // Create reflection to access the protected method
        $reflection = new \ReflectionClass($installModule);
        $method = $reflection->getMethod('runComposerUpdate');
        $method->setAccessible(true);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage("Failed to install module 'TestModule':");

        $method->invoke($installModule, $moduleName, $packageName);
    }

    public function testConstructorRealUsage(): void
    {
        // Test constructor is covered by creating a real instance used in tests
        $realInstall = new InstallModule(
            $this->modulesPath,
            $this->composerPath,
            $this->rootPath
        );

        $this->assertInstanceOf(HandlerInterface::class, $realInstall);

        // Test with trailing slashes to ensure they're trimmed
        $realInstallSlashes = new InstallModule(
            $this->modulesPath . '/',
            $this->composerPath,
            $this->rootPath . '/'
        );

        $this->assertInstanceOf(InstallModule::class, $realInstallSlashes);
    }

    public function testConstructorTrimsSlashes(): void
    {
        $modulesPath = '/path/to/modules/';
        $composerPath = '/path/to/composer.json';
        $rootPath = '/path/to/root/';

        $installModule = new InstallModule($modulesPath, $composerPath, $rootPath);

        // We can't directly access private properties, but we can test behavior indirectly
        $this->assertInstanceOf(InstallModule::class, $installModule);

        // Test the trimming works by checking the error message includes the trimmed path
        $dto = new InstallModuleCommand(['module_name' => 'TestModule']);

        try {
            $installModule->handle($dto);
        } catch (RuntimeException $e) {
            // The exception message should contain the trimmed path (without trailing slash)
            $this->assertStringContainsString('/path/to/modules', $e->getMessage());
            $this->assertStringNotContainsString('/path/to/modules/', $e->getMessage());
        }
    }

    /**
     * Test formatComposerJson method using real InstallModule class
     */
    public function testProtectedFormatComposerJsonMethod(): void
    {
        $installModule = new InstallModule($this->modulesPath, $this->composerPath, $this->rootPath);
        
        // Use reflection to test protected method on real class
        $reflection = new \ReflectionClass($installModule);
        $method = $reflection->getMethod('formatComposerJson');
        $method->setAccessible(true);
        
        $testData = [
            'name' => 'test/project',
            'require' => ['test/package' => '@dev'],
            'repositories' => [
                ['type' => 'path', 'url' => './modules/TestModule']
            ]
        ];
        
        $result = $method->invokeArgs($installModule, [$testData]);
        
        // Verify JSON formatting options
        $this->assertStringContainsString('"name": "test/project"', $result);
        $this->assertStringContainsString('./modules/TestModule', $result); // No escaped slashes
        $this->assertStringContainsString('    ', $result); // Pretty print indentation
        
        // Verify it's valid JSON
        $decoded = json_decode($result, true);
        $this->assertEquals($testData, $decoded);
    }

    /**
     * Test writeJsonToFile method with real file operations
     */
    public function testProtectedWriteJsonToFileMethod(): void
    {
        $installModule = new InstallModule($this->modulesPath, $this->composerPath, $this->rootPath);
        
        // Use reflection to test protected method
        $reflection = new \ReflectionClass($installModule);
        $method = $reflection->getMethod('writeJsonToFile');
        $method->setAccessible(true);
        
        $testFile = $this->tempDir . '/test.json';
        $jsonContent = '{"test": "data"}';
        
        $method->invokeArgs($installModule, [$testFile, $jsonContent]);
        
        $this->assertFileExists($testFile);
        $content = file_get_contents($testFile);
        $this->assertEquals($jsonContent . "\n", $content);
    }

    /**
     * Test writeJsonToFile method throws exception on write failure
     */
    public function testProtectedWriteJsonToFileThrowsExceptionOnFailure(): void
    {
        $installModule = new InstallModule($this->modulesPath, $this->composerPath, $this->rootPath);
        
        // Use reflection to test protected method
        $reflection = new \ReflectionClass($installModule);
        $method = $reflection->getMethod('writeJsonToFile');
        $method->setAccessible(true);
        
        // Try to write to an invalid path
        $invalidPath = '/nonexistent/directory/file.json';
        $jsonContent = '{"test": "data"}';
        
        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessageMatches('/Failed to write composer\.json:/');
        
        $method->invokeArgs($installModule, [$invalidPath, $jsonContent]);
    }
}